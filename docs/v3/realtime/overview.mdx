---
title: "Overview"
description: "Receive updates about your background tasks and events in real-time."
---

Realtime lets you subscribe to events happening in your Trigger.dev project as they happen, so you can build experiences for your users driven by real-time data in your tasks, with minimal latency and end-to-end typesafety.

- Receive updates about task run lifecycle events, such as was a task run started, completed, failed, re-attempted, or cancelled, and more.
- Receive task outputs and errors as they happen.
- Receive arbitrary data updates from your tasks using custom notifications, including streaming data.

Realtime lets you build experiences like this:

![realtime UI](/v3/realtime/realtime-ui.gif)

## Real world example

<Steps>
  <Step title="Define a Channel">
    A channel defines the tasks and notifications that you are interested in getting notified about. The type of the channel will be used later on the frontend to provide end-to-end typesafety.

    ```ts trigger/channels.ts
    import { channels, stream } from 'trigger.dev';
    import { performSpreadsheetActions, performSpreadsheetColumn, evaluateSpreadsheetCell } from "./trigger/spreadsheets";

    export const evaluateSpreadsheet = channels.define({
      id: "evaluate-spreadsheet",
      tasks: [
        performSpreadsheetActions,
        performSpreadsheetColumn,
        evaluateSpreadsheetCell
      ],
      notifications: {
        "cell.progress": z.object({
          row: z.number(),
          column: z.number(),
          value: z.number().int().min(0).max(100),
        }),
        "cell.stream": stream.text()
      }
    })
    ```

  </Step>
  <Step title="Create a Realtime Key">
    Create a `realtimeKey` from your backend using `channel.keys.create()`.

    ```ts
    // This is somewhere in your backend
    import { realtime } from 'trigger.dev';
    import { evaluateSpreadsheet } from "./trigger/channels";

    const realtimeKey = await evaluateSpreadsheet.keys.create();
    ```

    The `realtimeKey` is "tied" to the `evalulateSpreadsheet` channel, and can only be used to listen to events and notifications for that channel.

  </Step>
  <Step title="Use the Realtime Key">
    Trigger a task and pass in the `realtimeKey`:

    ```ts
    // This is somewhere in your backend
    import { performSpreadsheetActions } from "./trigger/spreadsheets";

    // Use the realtime key when triggering a task. Can also be used with batch trigger.
    await performSpreadsheetActions.trigger({ /* ... */ }, { realtimeKey })
    ```

  </Step>
  <Step title="Subscribe to events">
    Use our `@trigger.dev/realtime` SDK in your frontend to subscribe to events, using the
    `realtimeKey`:

    ```ts
    // This is somewhere in your frontend
    import { RealtimeClient } from '@trigger.dev/realtime';
    import type { evaluateSpreadsheet } from "./trigger/channels";
    //     ðŸ‘† **type-only** import

    // You'll need to pass the realtimeKey to your frontend
    const client = new RealtimeClient<typeof evaluateSpreadsheet>({ key: "your-realtime-key" });

    // Listen for a specific event on the perform-spreadsheet-actions task
    client.tasks.on('perform-spreadsheet-actions:success', (run) => {
      console.log('perform-spreadsheet-actions output = ', run.output); // ðŸ‘ˆ run.output matches the output type of the perform-spreadsheet-actions task
    });

    // Listen for a specific event on all tasks
    client.tasks.on('*:success', (run) => {
      switch (run.taskIdentifier) {
        case 'perform-spreadsheet-actions': {
          console.log('perform-spreadsheet-actions output = ', run.output);// ðŸ‘ˆ run.output matches the output type of the perform-spreadsheet-actions task
          break;
        }
        case 'evaluate-spreadsheet-cell': {
          console.log('evaluate-spreadsheet-cell output = ', run.output);// ðŸ‘ˆ run.output matches the output type of the evaluate-spreadsheet-cell task
          break;
        }
      }
    });

    // Listen for all events on a specific task
    client.tasks.on("perform-spreadsheet-actions:*", (run) => {
      switch (run.status) {
        case 'COMPLETED_SUCCESSFULLY': {
          console.log('perform-spreadsheet-actions output = ', run.output);// ðŸ‘ˆ run.output matches the output type of the perform-spreadsheet-actions task
          break;
        }
        case 'FAILED': {
          console.log('perform-spreadsheet-actions error = ', run.error);
          break;
        }
      }
    });

    // Listen to notifications
    client.notifications.on('cell.progress', (notification) => {
      console.log('cell.progress notification = ', notification); // ðŸ‘ˆ notification matches the type of the notification specified in the entrypoint
    });

    // Handle stream notifications
    client.notifications.on('cell.stream', (stream) => {
      for await (const chunk of stream) {
        console.log(chunk); // ðŸ‘ˆ chunk is a string
      }
    });
    ```

  </Step>
  <Step title="Send notifications from your tasks">
    Send notifications from your tasks using `myChannel.notifications.send()` or `channels.notifications.send()`:

    ```ts trigger/spreadsheets.ts
    import { tasks, channels } from 'trigger.dev';
    import { evaluateSpreadsheet } from "./entrypoints";
    import OpenAI from 'openai';

    const openai = new OpenAI({
      apiKey: process.env.OPEN_API_KEY,
    });

    export const evalulateSpreadsheetCell = tasks.define({
      id: "evalulate-spreadsheet-cell",
      run: async (payload: { row: number; column: number; input: string }) => {
        let value = // do some AI magic with payload.input here âœ¨

        // Send a notification
        await evaluateSpreadsheet.notifications.send("cell.progress", {
          row: payload.row,
          column: payload.column,
          value,
        });

        const response = await openai.chat.completions.create({
          model: 'gpt-3.5-turbo',
          stream: true,
          messages: [{ role: 'user', content: 'Say this is a test.' }],
        });

        // Send a stream notification
        response.pipeTo(evaluateSpreadsheet.notifications.write("cell.stream"));

        value = // do some more AI magic here âœ¨

        // Alternatively, you can use this form if you don't want to import the channel
        await channels.notifications.send<typeof evaluateSpreadsheet>("cell.progress", {
          row: payload.row,
          column: payload.column,
          value,
        });
      }
    });
    ```

    <Note>
      Notifications must be sent from inside a task, so it can be associated with the realtime key that was used to trigger the task.
    </Note>

  </Step>
</Steps>

## Minimal Realtime example

Here's an example of using Realtime to be notified of the status of a single task run:

<Steps>
  <Step title="Define a channel">
    
    ```ts trigger/channels.ts
    import { channels } from 'trigger.dev';
    import { myTask } from "./tasks";

    export const myChannel = channels.define({
      id: "my-channel",
      tasks: [myTask]
    });
    ```

  </Step>
  <Step title="Trigger using a Realtime Key">
    Create a `realtimeKey` from your backend using `channel.keys.create()`. Then use that realtime key to trigger a task. The following example uses a Remix action to create a Realtime Key:

    ```ts remix/app/routes/realtime/route.tsx
    // This is somewhere in your backend
    import { myChannel } from "./trigger/channels";
    import { myTask } from "./trigger/tasks";
    import { type ActionFunctionArgs, redirect } from "@remix-run/server-runtime";

    export async function action({ params, request }: ActionFunctionArgs) {
      // Create the realtime key
      const realtimeKey = await myChannel.keys.create();

      // Trigger the task, passing in the realtime key
      await myTask.trigger({ /* ... */  }, { realtimeKey });

      // Ideally you would store the realtime key in the database, session, or other storage

      return redirect(`/realtime/${realtimeKey}`);
    }
    ```

  </Step>
  <Step title="Listen for events using the Realtime Key">
    Now that we've created a realtime key and triggered a task with it, we can pass that key to our frontend and use the `@trigger.dev/realtime/react` SDK to listen for events. The following example continues to use a Remix example:

    ```ts remix/app/routes/realtime/$realtimeKey.tsx
    import { type LoaderFunctionArgs } from "@remix-run/server-runtime";
    import { useRealtime, RealtimeProvider } from "@trigger.dev/realtime/react";
    import type { myChannel } from "./trigger/channels";
    //     ðŸ‘† **type-only** import

    export async function loader({ params }: LoaderFunctionArgs) {
      // Retrieve the realtimeKey from the params, but alternatively this could be retrived from a database, session, etc.
      const realtimeKey = params["realtimeKey"] as string;

      // Return the realtimeKey so we can access it in the component
      return {
        realtimeKey,
      }
    }

    export default function RealtimeRoute() {
      const { realtimeKey } = useLoaderData<typeof loader>();

      return (
        <RealtimeProvider key={realtimeKey}>
          <MyComponent />
        </RealtimeProvider>
      )
    }

    function MyComponent() {
      const { event } = useRealtime<typeof myChannel>(
        "my-task"
      );

      if (!event) {
        return <div>Loading...</div>;
      }

      if (event.run.isQueued) {
        return <div>Queued</div>;
      } else if (event.run.isExecuting) {
        return <div>Running</div>;
      } else if (event.run.isSuccess) {
        return <pre>{JSON.stringify(event.run.output, null, 2)}</pre>;
      } else if (event.run.isFailed) {
        return <pre>{JSON.stringify(event.run.error, null, 2)}</pre>;
      } else {
        return <div>Unknown status: ${event.run.status}</div>;
      }
    }
    ```

  </Step>

</Steps>

## Realtime React SDK

The Realtime SDK is a universal library that can be used in both your backend and frontend code, but it was designed with the frontend in mind. It provides a low-level API to subscribe to raw events and notifications using Trigger.dev Realtime.

If you are building a React application, we recommend using the `@trigger.dev/realtime/react` SDK, which provides a higher-level API to subscribe to events and notifications using react hooks:

<CodeGroup>

```tsx Page.tsx
import { RealtimeProvider } from "@trigger.dev/realtime/react";

export function Page() {
  return (
    <RealtimeProvider key="your-realtime-key">
      <MyComponent />
    </RealtimeProvider>
  );
}
```

```tsx MyComponent.tsx
import { useRealtime } from "@trigger.dev/realtime/react";
import type { evaluateSpreadsheet } from "./trigger/channels";

export function MyComponent() {
  const { data, error, isLoading } = useRealtime<typeof evaluateSpreadsheet>(
    "perform-spreadsheet-actions:success"
  );

  if (isLoading) {
    return <div>Loading...</div>;
  }

  if (error) {
    return <div>Error: {error.message}</div>;
  }

  return <div>Output: {data.output}</div>;
}
```

</CodeGroup>

## Realtime React RSC

You can stream RSC directly from your tasks to your frontend via the Realtime RSC support

TBD

## Realtime UI

If you don't want to build your own UI, you can use the Realtime UI to visualize your tasks and events in real-time. The Realtime UI is a set of React components that you can use to build your own custom UI:

```tsx
import { RealtimeProvider } from "@trigger.dev/realtime/react";
import { TaskRunTableView } from "@trigger.dev/realtime/react/ui";

export function MyComponent() {
  return (
    <RealtimeProvider key="your-realtime-key">
      <TaskRunTableView />
    </RealtimeProvider>
  );
}
```

## Prisma Realtime

TBD
