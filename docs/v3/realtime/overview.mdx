---
title: "Overview"
description: "Receive updates about your background tasks and events in real-time."
---

Realtime lets you subscribe to events happening in your Trigger.dev project as they happen, so you can build experiences for your users driven by real-time data in your tasks, with minimal latency and end-to-end typesafety.

- Receive updates about task run lifecycle events, such as was a task run started, completed, failed, re-attempted, or cancelled, and more.
- Receive task outputs and errors as they happen.
- Receive arbitrary data updates from your tasks using custom notifications, including streaming data.

Realtime lets you build experiences like this:

![realtime UI](/v3/realtime/realtime-ui.gif)

## Getting started

<Steps>
  <Step title="Create an Entrypoint">
    An entrypoint defines the main task that will be triggered as well as any additional tasks and notifications. The type of the entrypoint will be used later on the frontend to provide end-to-end typesafety.

    ```ts trigger/entrypoints.ts
    import { entrypoints, stream } from 'trigger.dev';
    import { performSpreadsheetActions, performSpreadsheetColumn, evaluateSpreadsheetCell } from "./trigger/spreadsheets";

    export const evaluateSpreadsheet = entrypoints.define({
      id: "evaluate-spreadsheet",
      main: performSpreadsheetActions,
      subtasks: [
        performSpreadsheetColumn,
        evaluateSpreadsheetCell
      ],
      notifications: {
        "cell.progress": z.object({
          row: z.number(),
          column: z.number(),
          value: z.number().int().min(0).max(100),
        }),
        "cell.stream": stream.text()
      }
    })
    ```

  </Step>
  <Step title="Create a Realtime Key">
    Create a `realtimeKey` from your backend using `realtime.keys.create()`, passing in the entrypoint you created in the previous step. This is a one-time-use key that can only be used to trigger the entrypoint you specified.

    ```ts
    // This is somewhere in your backend
    import { realtime } from 'trigger.dev';
    import { evaluateSpreadsheet } from "./trigger/entrypoints";

    const realtimeKey = await realtime.keys.create({
      entryPoint: evaluateSpreadsheet,
      // Optional: filter events to a subset of tasks, otherwise all tasks listed in the entrypoint will be included
      taskIds: ['perform-spreadsheet-actions', 'evalulate-spreadsheet-cell'],
      // Optional: filter events to a subset of runs with the following tags
      tags: ['user:12345', 'org:12345'],
      // The default expiration is 15 minutes, but you can set a custom expiration
      ttl: 60 * 60 * 2, // 2 hours
    });
    ```

    The `realtimeKey` is "tied" to the `evalulateSpreadsheet` entrypoint, and can only be used to trigger that entrypoint.

    <Note>
      After the `realtimeKey` expires, you will no longer receive realtime notifications.
    </Note>

  </Step>
  <Step title="Use the Realtime Key">
    Trigger a task using `entrypoints.trigger` and pass in the `realtimeKey`:

    ```ts
    // This is somewhere in your backend
    import { type RealtimeKey, type EntrypointPayload, entrypoints } from 'trigger.dev';
    import type { evaluateSpreadsheet } from "./trigger/entrypoints";

    async function triggerEvalulateSpreadsheet(key: RealtimeKey, payload: EntrypointPayload<typeof evaluateSpreadsheet>) {
      // Payload is the type of the entrypoint task specified in the `trigger` option
      return await entrypoints.trigger<typeof evaluateSpreadsheet>(payload, { realtimeKey: key })
    }
    ```

    <Note>
      The `realtimeKey` is considered a public key, which means you can also trigger the entrypoint from your frontend client.
    </Note>

  </Step>
  <Step title="Subscribe to events">
    Use our `@trigger.dev/realtime` SDK in your frontend to subscribe to events, using the
    `realtimeKey`:

    ```ts
    // This is somewhere in your frontend
    import { RealtimeClient } from '@trigger.dev/realtime';
    import type { evaluateSpreadsheet } from "./trigger/entrypoints";
    //     ðŸ‘† **type-only** import

    // You'll need to pass the realtimeKey to your frontend
    const client = new RealtimeClient<typeof evaluateSpreadsheet>({ key: "your-realtime-key" });

    // Listen for a specific event on the perform-spreadsheet-actions task
    client.tasks.on('perform-spreadsheet-actions:success', (run) => {
      console.log('perform-spreadsheet-actions output = ', run.output); // ðŸ‘ˆ run.output matches the output type of the perform-spreadsheet-actions task
    });

    // Listen for a specific event on all tasks
    client.tasks.on('*:success', (run) => {
      switch (run.taskIdentifier) {
        case 'perform-spreadsheet-actions': {
          console.log('perform-spreadsheet-actions output = ', run.output);// ðŸ‘ˆ run.output matches the output type of the perform-spreadsheet-actions task
          break;
        }
        case 'evaluate-spreadsheet-cell': {
          console.log('evaluate-spreadsheet-cell output = ', run.output);// ðŸ‘ˆ run.output matches the output type of the evaluate-spreadsheet-cell task
          break;
        }
      }
    });

    // Listen for all events on a specific task
    client.tasks.on("perform-spreadsheet-actions:*", (run) => {
      switch (run.status) {
        case 'COMPLETED_SUCCESSFULLY': {
          console.log('perform-spreadsheet-actions output = ', run.output);// ðŸ‘ˆ run.output matches the output type of the perform-spreadsheet-actions task
          break;
        }
        case 'FAILED': {
          console.log('perform-spreadsheet-actions error = ', run.error);
          break;
        }
      }
    });

    // Listen to notifications
    client.notifications.on('cell.progress', (notification) => {
      console.log('cell.progress notification = ', notification); // ðŸ‘ˆ notification matches the type of the notification specified in the entrypoint
    });

    // Handle stream notifications
    client.notifications.on('cell.stream', (stream) => {
      for await (const chunk of stream) {
        console.log(chunk); // ðŸ‘ˆ chunk is a string
      }
    });
    ```

  </Step>
  <Step title="Send notifications from your tasks">
    Send notifications from your tasks using `myEntrypoint.notifications.send()` or `entrypoints.notifications.send()`:

    ```ts trigger/spreadsheets.ts
    import { tasks, entrypoints } from 'trigger.dev';
    import { evaluateSpreadsheet } from "./entrypoints";
    import OpenAI from 'openai';

    const openai = new OpenAI({
      apiKey: process.env.OPEN_API_KEY,
    });

    export const evalulateSpreadsheetCell = tasks.define({
      id: "evalulate-spreadsheet-cell",
      run: async (payload: { row: number; column: number; input: string }) => {
        let value = // do some AI magic with payload.input here âœ¨

        // Send a notification
        await evaluateSpreadsheet.send("cell.progress", {
          row: payload.row,
          column: payload.column,
          value,
        });

        const response = await openai.chat.completions.create({
          model: 'gpt-3.5-turbo',
          stream: true,
          messages: [{ role: 'user', content: 'Say this is a test.' }],
        });

        // Send a stream notification
        response.pipeTo(evaluateSpreadsheet.notifications.write("cell.stream"));

        value = // do some more AI magic here âœ¨

        // Alternatively, you can use this form if you don't want to import the entrypoint
        await entrypoints.notifications.send<typeof evaluateSpreadsheet>("cell.progress", {
          row: payload.row,
          column: payload.column,
          value,
        });
      }
    });
    ```

  </Step>
</Steps>

## Realtime React SDK

The Realtime SDK is a universal library that can be used in both your backend and frontend code, but it was designed with the frontend in mind. It provides a low-level API to subscribe to raw events and notifications using Trigger.dev Realtime.

If you are building a React application, we recommend using the `@trigger.dev/realtime/react` SDK, which provides a higher-level API to subscribe to events and notifications using react hooks:

<CodeGroup>

```tsx Page.tsx
import { RealtimeProvider } from "@trigger.dev/realtime/react";

export function Page() {
  return (
    <RealtimeProvider key="your-realtime-key">
      <MyComponent />
    </RealtimeProvider>
  );
}
```

```tsx MyComponent.tsx
import { useRealtime } from "@trigger.dev/realtime/react";
import type { evaluateSpreadsheet } from "./trigger/entrypoints";

export function MyComponent() {
  const { data, error, isLoading } = useRealtime<typeof evaluateSpreadsheet>(
    "perform-spreadsheet-actions:success"
  );

  if (isLoading) {
    return <div>Loading...</div>;
  }

  if (error) {
    return <div>Error: {error.message}</div>;
  }

  return <div>Output: {data.output}</div>;
}
```

</CodeGroup>
